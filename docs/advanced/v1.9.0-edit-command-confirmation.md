# v1.9.0 - Edit Command & Interactive Confirmation

**üéØ Goal:** Add task editing capabilities and safety confirmations for destructive operations

**üì¶ The Problems We're Solving:**

**Problem 1 - No way to modify existing tasks:**

```bash
# Before v1.9.0 - Must delete and recreate to fix mistakes
$ todo list
  5  M  [ ]  Fix bug in lgoin system  work  in 2 days

# Oops, typo! Only option: remove and recreate
$ todo remove 5
‚úì Task removed: Fix bug in lgoin system

$ todo add "Fix bug in login system" --priority medium --tag work --due 2026-02-12
‚úì Task added

# Problems:
# - Lost the original task ID (#5 ‚Üí #6)
# - Lost the created_at timestamp
# - Tedious for simple corrections
```

**Problem 2 - Accidental deletions:**

```bash
# Before v1.9.0 - No confirmation, immediate deletion
$ todo remove 5
‚úì Task removed: Fix critical production bug

# "Wait, I meant task 4, not 5!" üò±
# No way to undo!
```

**After v1.9.0 - Edit command + Confirmations:**

```bash
# Edit tasks in place
$ todo edit 5 --text "Fix bug in login system"
‚úì Task #5 updated:
  ‚Ä¢ text ‚Üí Fix bug in login system

# Task ID preserved (#5 stays #5)
# Created date preserved
# Quick and efficient!

# Safe deletions with confirmation
$ todo remove 5
Remove task 'Fix critical production bug'? [y/N]: n
Removal cancelled.

# Disaster averted! ‚úì
```

**Benefits:**

‚úÖ **Edit in place** - Fix typos and adjust tasks without recreating  
‚úÖ **Preserve history** - Keep task ID and creation timestamp  
‚úÖ **Partial updates** - Change only what you need  
‚úÖ **Smart validation** - Prevents no-op changes  
‚úÖ **Safe operations** - Confirmation prompts prevent accidents  
‚úÖ **Script-friendly** - `--yes` flag to skip confirmations  

---

## üß† Key Concepts

### Feature vs Enhancement

**Understanding the classification:**

| Type | Definition | Example |
|------|------------|---------|
| **Feature** | NEW functionality that didn't exist before | Edit command - completely new capability |
| **Enhancement** | IMPROVES existing functionality | Remove confirmation - same command, better UX |

**Why Edit is a Feature:**

- Adds new command: `todo edit`
- New subcommand in `Commands` enum
- New alias: `todo e`
- Appears under "Added" in changelog
- Introduces new user-facing capability

**Why Confirmation is an Enhancement:**

- Improves existing commands (`remove`, `clear`)
- Same commands, different behavior
- Appears under "Improved" in changelog
- Makes existing features safer/better

### Let-Chains (RFC 2497)

**New Rust syntax for cleaner conditionals:**

**Before (nested if-let):**

```rust
if let Some(new_text) = text {
    if new_text != task.text {
        task.text = new_text;
        changes.push("text updated");
    }
}
```

**After (let-chain):**

```rust
if let Some(new_text) = text && new_text != task.text {
    task.text = new_text;
    changes.push("text updated");
}
```

**How it works:**

```rust
if PATTERN && CONDITION {
    // Both must be true
}
```

1. First: Pattern matching (`let Some(x) = option`)
2. Then: Boolean condition (`x != old_value`)
3. Both must succeed for block to execute

**Benefits:**

- ‚úÖ Flatter code (no nesting)
- ‚úÖ Reads left-to-right
- ‚úÖ More functional style
- ‚úÖ Compiler optimizes both paths

**Real example from Edit command:**

```rust
// Update priority if provided AND different
if let Some(new_priority) = priority && task.priority != new_priority {
    task.priority = new_priority;
    changes.push(format!("priority ‚Üí {}", new_priority.letter()));
}
```

**Pattern:**

```
if let Some(value) = option  ‚Üê Extract value from Option
   && value != current       ‚Üê Check if actually different
```

### Buffered I/O with `io::stdout().flush()`

**Problem: Terminal output buffering**

```rust
print!("Enter name: ");  // ‚Üê Stays in buffer!
let mut input = String::new();
io::stdin().read_line(&mut input)?;  // ‚Üê Prompt not visible yet!
```

**Terminal output is buffered:**

- `print!()` writes to buffer, not screen
- Buffer flushes on newline (`\n`) or when full
- User sees nothing until buffer flushes
- Confusing UX: cursor blinks, no prompt visible

**Solution: Manual flush**

```rust
print!("Enter name: ");
io::stdout().flush()?;  // ‚Üê Force immediate display
let mut input = String::new();
io::stdin().read_line(&mut input)?;
```

**In our confirm() function:**

```rust
fn confirm(message: &str) -> Result<bool> {
    print!("{} ", message.yellow());
    io::stdout().flush()?;  // ‚Üê Critical! Shows prompt immediately
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    let response = input.trim().to_lowercase();
    Ok(matches!(response.as_str(), "y" | "yes"))
}
```

**Why it matters:**

1. **UX** - User sees prompt before typing
2. **Professional** - Behaves like standard CLIs
3. **Clear** - No confusion about what to enter

**Technical details:**

- `flush()` returns `Result<()>` (can fail)
- Use `?` operator to propagate errors
- Only needed for `print!()` (not `println!()`)
- `println!()` auto-flushes due to newline

### Pattern Matching with `matches!` Macro

**Elegant way to check if value matches patterns:**

**Before (verbose):**

```rust
let response = input.trim().to_lowercase();
let confirmed = response == "y" || response == "yes";
```

**After (matches! macro):**

```rust
let response = input.trim().to_lowercase();
let confirmed = matches!(response.as_str(), "y" | "yes");
```

**Syntax:**

```rust
matches!(expression, pattern1 | pattern2 | ...)
// Returns bool: true if expression matches any pattern
```

**Benefits:**

- ‚úÖ Concise
- ‚úÖ Reads naturally ("does response match y or yes?")
- ‚úÖ Compile-time pattern checking
- ‚úÖ Exhaustiveness checking with enums

**Why not accept empty Enter?**

```rust
// Tempting but DANGEROUS for destructive operations:
matches!(response.as_str(), "" | "y" | "yes")

// Accidental Enter = deletion! üò±
```

**Our design choice:**

```rust
// Safer: Require explicit confirmation
matches!(response.as_str(), "y" | "yes")
// Default is "no" - better for destructive ops
```

**The `[y/N]` convention:**

- Uppercase letter = default
- `[y/N]` ‚Üí default is N (no)
- `[Y/n]` ‚Üí default is Y (yes)
- Our prompts use `[y/N]` for safety

### Change Tracking with `Vec<String>`

**Pattern: Collect changes to show user**

```rust
let mut changes = Vec::new();

// Track each change
if text_changed {
    changes.push(format!("text ‚Üí {}", new_text));
}
if priority_changed {
    changes.push(format!("priority ‚Üí {}", new_priority));
}

// Display summary
if changes.is_empty() {
    println!("No changes made");
} else {
    println!("Task #{} updated:", id);
    for change in changes {
        println!("  ‚Ä¢ {}", change);
    }
}
```

**Why this pattern?**

1. **Clear feedback** - User sees exactly what changed
2. **No-op detection** - Empty vec = nothing changed
3. **Grouped output** - All changes shown together
4. **Professional UX** - Mirrors git, cargo behavior

**Output example:**

```bash
$ todo edit 5 --text "New" --priority high --due 2026-03-15
‚úì Task #5 updated:
  ‚Ä¢ text ‚Üí New
  ‚Ä¢ priority ‚Üí H
  ‚Ä¢ due date ‚Üí 2026-03-15
```

### Preserving Task Identity

**Critical design decision:**

```rust
// Edit command preserves:
let index = id - 1;
let task = &mut tasks[index];

// ‚úì Keep same ID (user sees same number)
// ‚úì Keep created_at (history preserved)
// ‚úì Keep completed status (done/undone state)

// Only modify requested fields:
task.text = new_text;        // ‚Üê User explicitly changed
task.priority = new_priority; // ‚Üê User explicitly changed
// created_at = unchanged      // ‚Üê Preserved automatically
```

**Why this matters:**

| Scenario | Without Edit | With Edit |
|----------|--------------|-----------|
| Fix typo in task #5 | Remove #5, add ‚Üí becomes #6 | Edit #5 ‚Üí stays #5 |
| Created 3 days ago | Lost, becomes "created now" | Preserved, still "3 days ago" |
| Task done status | Lost, becomes pending | Preserved, stays done |

**User benefits:**

- Task references stay valid (scripts, notes)
- History tracking works correctly
- Sort by creation date still meaningful
- Professional behavior (like git commit --amend)

---

## üìù Implementation Details

### New Imports

```rust
use std::io::{self, Write};  // For buffered I/O and flush
```

**What we import:**

- `io` - Input/output module
- `io::Write` - Trait for `flush()` method

**Why needed:**

- `print!()` outputs to stdout
- `flush()` requires `Write` trait in scope
- `read_line()` reads from stdin

### Version Update

```rust
#[command(version = "1.9.0")]  // ‚Üê Update from "1.8.0"
```

**Shows in:**

```bash
$ todo --version
todo-cli 1.9.0
```

### The `confirm()` Helper Function

**Full implementation:**

```rust
/// Prompts the user for confirmation.
///
/// # Arguments
///
/// * `message` - The confirmation message to display
///
/// # Returns
///
/// `true` if the user confirms (y/Y/yes), `false` otherwise
fn confirm(message: &str) -> Result<bool> {
    print!("{} ", message.yellow());
    io::stdout().flush()?;

    let mut input = String::new();
    io::stdin().read_line(&mut input)?;

    let response = input.trim().to_lowercase();
    Ok(matches!(response.as_str(), "y" | "yes"))
}
```

**Line-by-line breakdown:**

```rust
print!("{} ", message.yellow());
```

- Display colored prompt
- No newline (user types on same line)
- Adds space after message

```rust
io::stdout().flush()?;
```

- Force immediate display
- Returns `Result` - can fail if stdout is broken
- `?` propagates error to caller

```rust
let mut input = String::new();
```

- Create mutable empty string
- Will hold user's response

```rust
io::stdin().read_line(&mut input)?;
```

- Read entire line (until Enter)
- Includes newline character
- `?` propagates I/O errors

```rust
let response = input.trim().to_lowercase();
```

- `trim()` removes whitespace and newline
- `to_lowercase()` normalizes to lowercase
- "Y\n" ‚Üí "y", "YES\n" ‚Üí "yes"

```rust
Ok(matches!(response.as_str(), "y" | "yes"))
```

- Check if response is "y" or "yes"
- Returns `true` or `false`
- Wrapped in `Ok()` for Result type

### Updated `Commands` Enum

**Add Edit variant:**

```rust
/// Edit an existing task
#[command(visible_alias = "e")]
#[command(long_about = "Edit an existing task\n\n\
    Modify task properties like text, priority, tags, or due date.\n\
    Only specify the fields you want to change.")]
Edit {
    /// Task ID number
    #[arg(value_name = "ID")]
    id: usize,

    /// New task description
    #[arg(long)]
    text: Option<String>,

    /// New priority level
    #[arg(long, value_enum)]
    priority: Option<Priority>,

    /// Replace tags (use multiple times: -t work -t urgent)
    #[arg(long, short = 't', value_name = "TAG")]
    tag: Vec<String>,

    /// New due date (YYYY-MM-DD)
    #[arg(long, value_parser = clap::value_parser!(NaiveDate))]
    due: Option<NaiveDate>,

    /// Remove due date
    #[arg(long, conflicts_with = "due")]
    clear_due: bool,

    /// Remove all tags
    #[arg(long)]
    clear_tags: bool,
},
```

**Key attributes:**

```rust
#[command(visible_alias = "e")]
```

- User can type `todo e` instead of `todo edit`
- Shown in help output

```rust
#[arg(long, conflicts_with = "due")]
```

- `--clear-due` and `--due` are mutually exclusive
- Clap enforces this at compile time
- Error if user tries both

```rust
#[arg(long, value_enum)]
```

- Priority values validated against enum
- Auto-generates possible values in help
- Type-safe parsing

**Add confirmation flags:**

```rust
Remove {
    /// Task ID number
    #[arg(value_name = "ID")]
    id: usize,

    /// Skip confirmation prompt
    #[arg(long, short = 'y')]
    yes: bool,
},

Clear {
    /// Skip confirmation prompt
    #[arg(long, short = 'y')]
    yes: bool,
},
```

**Design choice:**

- Long form: `--yes` (descriptive)
- Short form: `-y` (quick for scripts)
- Default: `false` (require confirmation)

### Edit Command Implementation

**Complete handler:**

```rust
Commands::Edit {
    id,
    text,
    priority,
    tag,
    due,
    clear_due,
    clear_tags,
} => {
    let mut tasks = load_tasks()?;
    validate_task_id(id, tasks.len())?;

    let index = id - 1;
    let task = &mut tasks[index];

    let mut changes = Vec::new();

    // Update text if provided AND different
    if let Some(new_text) = text {
        if new_text.trim().is_empty() {
            return Err(anyhow::anyhow!("Task text cannot be empty"));
        }
        if task.text != new_text {
            task.text = new_text.clone();
            changes.push(format!("text ‚Üí {}", new_text.bright_white()));
        }
    }

    // Update priority if provided AND different
    if let Some(new_priority) = priority && task.priority != new_priority {
        task.priority = new_priority;
        changes.push(format!("priority ‚Üí {}", new_priority.letter()));
    }

    // Update tags
    if clear_tags {
        if !task.tags.is_empty() {
            task.tags.clear();
            changes.push("tags ‚Üí cleared".dimmed().to_string());
        }
    } else if !tag.is_empty() && task.tags != tag {
        task.tags = tag;
        changes.push(format!("tags ‚Üí [{}]", task.tags.join(", ").cyan()));
    }

    // Update due date
    if clear_due {
        if task.due_date.is_some() {
            task.due_date = None;
            changes.push("due date ‚Üí cleared".dimmed().to_string());
        }
    } else if let Some(new_due) = due && task.due_date != Some(new_due) {
        task.due_date = Some(new_due);
        changes.push(format!("due date ‚Üí {}", new_due.to_string().cyan()));
    }

    // Check if anything was actually changed
    if changes.is_empty() {
        println!(
            "{}",
            "No changes made (values are already set to the specified values).".yellow()
        );
        return Ok(());
    }

    save_tasks(&tasks)?;

    println!("{} Task #{} updated:", "‚úì".green(), id);
    for change in changes {
        println!("  ‚Ä¢ {}", change);
    }
}
```

**Flow:**

1. **Load and validate** - Get tasks, check ID exists
2. **Get mutable reference** - `&mut tasks[index]`
3. **Process each field** - Check if changed, update, track
4. **Validate changes** - If empty, warn and exit
5. **Save and display** - Write to disk, show changes

**Text validation:**

```rust
if new_text.trim().is_empty() {
    return Err(anyhow::anyhow!("Task text cannot be empty"));
}
```

- Prevents empty tasks
- Catches whitespace-only input
- Clear error message

**Let-chain usage:**

```rust
if let Some(new_priority) = priority && task.priority != new_priority {
    // Only executes if:
    // 1. priority was provided (Some)
    // 2. AND it's different from current
}
```

**Tag handling logic:**

```rust
if clear_tags {
    // Clear operation takes precedence
} else if !tag.is_empty() && task.tags != tag {
    // Only replace if tags provided AND different
}
```

**Design pattern:**

- Clear flags checked first
- Set operations only if value provided
- Change detection prevents no-ops
- Graceful handling of "no changes"

### Updated Remove Command

**Before (v1.8.0):**

```rust
Commands::Remove { id } => {
    let mut tasks = load_tasks()?;
    validate_task_id(id, tasks.len())?;

    let index = id - 1;
    let removed_task = tasks.remove(index);
    save_tasks(&tasks)?;
    println!("{} {}", "‚úì Task removed:".red(), removed_task.text.dimmed());
}
```

**After (v1.9.0):**

```rust
Commands::Remove { id, yes } => {
    let mut tasks = load_tasks()?;
    validate_task_id(id, tasks.len())?;

    let index = id - 1;
    let task_text = &tasks[index].text;

    if !yes {
        println!(
            "\n{} {}",
            "Remove task:".red().bold(),
            task_text.bright_white()
        );

        if !confirm("Are you sure? [y/N]:")? {
            println!("{}", "Removal cancelled.".yellow());
            return Ok(());
        }
    }

    let removed_task = tasks.remove(index);
    save_tasks(&tasks)?;
    println!("{} {}", "‚úì Task removed:".red(), removed_task.text.dimmed());
}
```

**Changes:**

1. **Accept `yes` parameter** - Flag to skip confirmation
2. **Show task before asking** - User knows what they're deleting
3. **Call confirm() if not --yes** - Interactive prompt
4. **Handle cancellation** - Early return with message
5. **Same deletion logic** - If confirmed (or --yes)

**UX flow:**

```bash
$ todo remove 5
Remove task: Fix critical production bug
Are you sure? [y/N]: n
Removal cancelled.

$ todo remove 5 --yes
‚úì Task removed: Fix critical production bug
```

### Updated Clear Command

**Before (v1.8.0):**

```rust
Commands::Clear => {
    let path = get_date_file_path()?;

    if path.exists() {
        fs::remove_file(&path).context(format!("Failed to remove {}", path.display()))?;
        println!("{}", "‚úì All tasks have been removed".red().bold());
    } else {
        println!("No tasks to remove");
    }
}
```

**After (v1.9.0):**

```rust
Commands::Clear { yes } => {
    let path = get_date_file_path()?;

    if !path.exists() {
        println!("No tasks to remove");
        return Ok(());
    }

    let tasks = load_tasks()?;
    let count = tasks.len();

    if !yes {
        println!(
            "\n{} {} tasks will be permanently deleted!",
            "WARNING:".red().bold(),
            count
        );

        if !confirm("Are you sure? [y/N]:")? {
            println!("{}", "Clear cancelled.".yellow());
            return Ok(());
        }
    }

    fs::remove_file(&path).context(format!("Failed to remove {}", path.display()))?;
    println!("{}", "‚úì All tasks have been removed".red().bold());
}
```

**Changes:**

1. **Accept `yes` parameter** - Skip confirmation flag
2. **Early return if no tasks** - Before loading
3. **Load tasks to count** - Show how many will be deleted
4. **Show warning with count** - "25 tasks will be deleted!"
5. **Confirm before deletion** - Unless --yes
6. **Handle cancellation** - Early return with message

**UX comparison:**

```bash
# Before
$ todo clear
‚úì All tasks have been removed  # Too easy!

# After
$ todo clear
WARNING: 25 tasks will be permanently deleted!
Are you sure? [y/N]: 

# Script mode
$ todo clear --yes
‚úì All tasks have been removed
```

---

## üéØ Design Decisions

### Why Confirmation Defaults to "No"

**Option 1: Accept empty Enter as "yes"**

```rust
matches!(response.as_str(), "" | "y" | "yes")  // Dangerous!
```

**Problems:**

- ‚ùå Accidental Enter = deletion
- ‚ùå Cursor in wrong place = deletion
- ‚ùå User confusion = deletion
- ‚ùå Not safe for destructive operations

**Option 2: Require explicit "y" or "yes"** ‚úÖ

```rust
matches!(response.as_str(), "y" | "yes")  // Safer!
```

**Benefits:**

- ‚úÖ User must type to confirm
- ‚úÖ Empty Enter = cancel (safe default)
- ‚úÖ Follows Unix convention for dangerous ops
- ‚úÖ Prevents accidental data loss

**Industry standard:**

- `rm -i` requires explicit y
- `git` prompts require explicit confirmation
- Package managers require explicit y
- Destructive operations = explicit confirmation

### Why `--yes` Flag Exists

**Use case: Automation and scripts**

```bash
#!/bin/bash
# Daily cleanup script

# Remove old completed tasks (hypothetical feature)
for id in $(todo list --status done | awk '{print $1}'); do
    todo remove $id --yes  # ‚Üê No prompt, auto-confirm
done

# Clear test environment
if [[ $ENV == "test" ]]; then
    todo clear --yes  # ‚Üê Non-interactive
fi
```

**Without --yes flag:**

- Scripts hang waiting for input
- Can't automate destructive operations
- Must use `echo y | todo remove 5` (hacky)

**With --yes flag:**

- Clean, explicit intent
- Self-documenting code
- Standard pattern (apt-get -y, yum -y, cargo --force)

### Why Edit Preserves Task ID

**Alternative design: Delete + Add**

```rust
// User types: todo edit 5 --text "New"
// Could implement as:
let old_task = tasks.remove(id - 1);
let new_task = Task::new("New", old_task.priority, ...);
tasks.push(new_task);
// New task gets new ID!
```

**Problems with delete+add:**

1. **ID instability** - Task #5 becomes #6 or #11
2. **Lost references** - User notes say "see task #5"
3. **Broken scripts** - `todo done 5` now wrong task
4. **Lost history** - Creation timestamp lost

**Edit command benefits:**

1. **Stable IDs** - #5 stays #5 forever
2. **References work** - "task #5" always means same task
3. **Scripts work** - IDs don't change under us
4. **History preserved** - Created 3 days ago stays that way

**Real-world analogy:**

- Git commit --amend (keeps commit hash)
- Database UPDATE (keeps primary key)
- File edit (keeps inode)

### Why Let-Chains Over Nested If-Let

**Nested approach (traditional):**

```rust
if let Some(new_text) = text {
    if new_text != task.text {
        if !new_text.trim().is_empty() {
            task.text = new_text;
            changes.push("text updated");
        }
    }
}
```

**Problems:**

- 3 levels of nesting
- Hard to read
- Rightward drift
- Feels imperative

**Let-chain approach (modern):**

```rust
if let Some(new_text) = text 
   && new_text != task.text 
   && !new_text.trim().is_empty() 
{
    task.text = new_text;
    changes.push("text updated");
}
```

**Benefits:**

- Flat structure
- Reads left-to-right
- All conditions at same level
- More functional style

**When let-chains shine:**

```rust
// Perfect use case: unwrap + validate
if let Some(value) = option && value > 0 { ... }

// Alternative: nested
if let Some(value) = option {
    if value > 0 { ... }
}
```

### Change Tracking Design

**Why track changes in Vec?**

**Alternative 1: Print immediately**

```rust
if text_changed {
    println!("text changed to: {}", new_text);
}
if priority_changed {
    println!("priority changed to: {}", new_priority);
}
```

**Problems:**

- Scattered output
- Can't detect "no changes" until end
- Inconsistent formatting

**Alternative 2: Boolean flags**

```rust
let mut anything_changed = false;
if text_changed { anything_changed = true; }
if priority_changed { anything_changed = true; }
```

**Problems:**

- Loses information about WHAT changed
- Can't show detailed summary

**Chosen approach: Vec of changes** ‚úÖ

```rust
let mut changes = Vec::new();
if text_changed {
    changes.push(format!("text ‚Üí {}", new_text));
}

if changes.is_empty() {
    println!("No changes");
} else {
    for change in changes {
        println!("  ‚Ä¢ {}", change);
    }
}
```

**Benefits:**

- ‚úÖ Grouped output
- ‚úÖ Detailed summary
- ‚úÖ Easy no-op detection
- ‚úÖ Professional UX

### TableLayout Architecture Refactoring

**Purpose:** Separate layout calculations from rendering logic

**Before v1.9.0 - Tightly coupled:**

```rust
fn display_task_tabular(
    number: usize,
    task: &Task,
    task_width: usize,     // ‚Üê Passed as parameters
    tags_width: usize,     // ‚Üê Passed as parameters
    due_width: usize,      // ‚Üê Not used but passed anyway
) {
    // Rendering logic mixed with layout knowledge
}

// Caller must manage all width values
let (task_width, tags_width, due_width) = calculate_column_widths(&tasks);
display_task_tabular(number, task, task_width, tags_width, due_width);
```

**Problems:**

- ‚ùå Multiple parameters to pass around
- ‚ùå Easy to mix up parameter order
- ‚ùå Tight coupling between calculation and rendering
- ‚ùå Adding new column requires updating all call sites

**After v1.9.0 - TableLayout struct:**

```rust
struct TableLayout {
    task_width: usize,
    tags_width: usize,
    due_width: usize,
}

impl TableLayout {
    fn calculate(tasks: &[(usize, &Task)]) -> Self {
        let mut max_task_len = 10;
        let mut max_tags_len = 4;
        let mut max_due_len = 3;

        // ... width calculation logic ...

        Self {
            task_width: max_task_len.min(40),
            tags_width: max_tags_len.min(20),
            due_width: max_due_len.min(20),
        }
    }
}

// Cleaner function signature
fn display_task_tabular(
    number: usize,
    task: &Task,
    layout: &TableLayout,  // ‚Üê Single parameter
) {
    // Use layout.task_width, layout.tags_width
}

// Caller code is cleaner
let layout = TableLayout::calculate(&tasks);
display_task_tabular(number, task, &layout);
```

**Benefits:**

‚úÖ **Single Responsibility** - TableLayout manages widths, display function renders  
‚úÖ **Reduced coupling** - Display function doesn't know HOW widths are calculated  
‚úÖ **Easier to extend** - Add new column? Just update TableLayout struct  
‚úÖ **Type safety** - Can't mix up width parameters  
‚úÖ **Cleaner signatures** - One layout parameter instead of three width parameters  

**Design Pattern:**

This is the **Builder Pattern** - encapsulating complex object construction:

```rust
// Instead of this:
let widths = (40, 20, 20);  // What do these numbers mean?

// We have this:
let layout = TableLayout::calculate(&tasks);
// Clear what it is and where it comes from
```

**Why this matters:**

- **Future columns**: Add `priority_width`, `id_width` ‚Üí just add fields to struct
- **Alternative layouts**: Could create `CompactLayout`, `WideLayout` variants
- **Testability**: Can test layout calculation independently of rendering

---

## üß™ Testing the Feature

### Edit Command Tests

**Test 1: Change text**

```bash
$ todo add "Original text"
$ todo edit 1 --text "Updated text"
‚úì Task #1 updated:
  ‚Ä¢ text ‚Üí Updated text

$ todo list
  1  M  ‚è≥  Updated text
```

**Test 2: Change multiple fields**

```bash
$ todo edit 1 --text "New" --priority high --due 2026-03-15
‚úì Task #1 updated:
  ‚Ä¢ text ‚Üí New
  ‚Ä¢ priority ‚Üí H
  ‚Ä¢ due date ‚Üí 2026-03-15
```

**Test 3: No-op detection**

```bash
$ todo edit 1 --priority high  # Already high
No changes made (values are already set to the specified values).
```

**Test 4: Empty text validation**

```bash
$ todo edit 1 --text ""
Error: Task text cannot be empty

$ todo edit 1 --text "   "
Error: Task text cannot be empty
```

**Test 5: Clear operations**

```bash
$ todo add "Task" --tag work --tag urgent --due 2026-03-01
$ todo edit 1 --clear-tags
‚úì Task #1 updated:
  ‚Ä¢ tags ‚Üí cleared

$ todo edit 1 --clear-due
‚úì Task #1 updated:
  ‚Ä¢ due date ‚Üí cleared
```

**Test 6: Invalid ID**

```bash
$ todo edit 999 --text "New"
Error: Task ID 999 is invalid (valid range: 1-5)
```

**Test 7: Task ID preserved**

```bash
$ todo add "Task 1"
$ todo add "Task 2"
$ todo edit 1 --text "Modified"
$ todo list
  1  M  ‚è≥  Modified  # Still #1!
  2  M  ‚è≥  Task 2
```

**Test 8: Alias works**

```bash
$ todo e 1 --text "Via alias"
‚úì Task #1 updated:
  ‚Ä¢ text ‚Üí Via alias
```

### Confirmation Tests

**Test 9: Remove with confirmation**

```bash
$ todo remove 1

Remove task: Important task
Are you sure? [y/N]: y
‚úì Task removed: Important task
```

**Test 10: Remove cancelled**

```bash
$ todo remove 1

Remove task: Important task
Are you sure? [y/N]: n
Removal cancelled.

$ todo list
  1  M  ‚è≥  Important task  # Still exists
```

**Test 11: Remove with --yes**

```bash
$ todo remove 1 --yes
‚úì Task removed: Important task
# No prompt!
```

**Test 12: Remove with -y (short form)**

```bash
$ todo remove 1 -y
‚úì Task removed: Important task
```

**Test 13: Clear with confirmation**

```bash
$ todo clear

WARNING: 5 tasks will be permanently deleted!
Are you sure? [y/N]: yes
‚úì All tasks have been removed
```

**Test 14: Clear cancelled**

```bash
$ todo clear

WARNING: 5 tasks will be permanently deleted!
Are you sure? [y/N]: n
Clear cancelled.

$ todo list  # Still has 5 tasks
```

**Test 15: Clear with --yes**

```bash
$ todo clear --yes
‚úì All tasks have been removed
```

**Test 16: Clear when empty**

```bash
$ todo clear
No tasks to remove
# No prompt needed
```

### Edge Cases

**Test 17: Edit completed task**

```bash
$ todo add "Task"
$ todo done 1
$ todo edit 1 --priority high
‚úì Task #1 updated:
  ‚Ä¢ priority ‚Üí H

$ todo list --status done
  1  H  ‚úÖ  Task  # Still completed, priority changed
```

**Test 18: Conflicting flags**

```bash
$ todo edit 1 --due 2026-03-01 --clear-due
error: the argument '--due <DATE>' cannot be used with '--clear-due'
```

**Test 19: Confirmation with "YES" (uppercase)**

```bash
$ todo remove 1
Are you sure? [y/N]: YES
‚úì Task removed  # Works! (lowercased internally)
```

**Test 20: Confirmation with invalid input**

```bash
$ todo remove 1
Are you sure? [y/N]: maybe
Removal cancelled.  # Anything but y/yes = cancel
```

---

## üìä Code Quality Metrics

### Lines of Code Impact

| Component | Added | Changed | Total |
|-----------|-------|---------|-------|
| `confirm()` function | 13 | 0 | 13 |
| Edit command | 65 | 0 | 65 |
| Remove update | 0 | 12 | 12 |
| Clear update | 0 | 15 | 15 |
| Commands enum | 30 | 5 | 35 |
| TableLayout struct | 25 | 0 | 25 |
| **Total** | **133** | **32** | **165** |

### Complexity Added

- **Cyclomatic complexity**: +8 (Edit command has 8 decision paths)
- **Cognitive complexity**: Low (well-structured, clear flow)
- **Maintainability**: High (single responsibility, well-commented)
- **Coupling reduction**: TableLayout reduces parameter passing

### Code Quality Improvements

‚úÖ **Separation of Concerns** - Layout calculation separated from rendering  
‚úÖ **Type Safety** - Struct encapsulation prevents width parameter mix-ups  
‚úÖ **Extensibility** - Easy to add new columns or layout variants  
‚úÖ **Readability** - `layout.task_width` is clearer than anonymous parameters

### Test Coverage Needed

- Edit command: 8 test cases
- Confirmation: 6 test cases
- Edge cases: 6 test cases
- **Total**: 20 test cases minimum

---

## üìö Learning Outcomes

After implementing v1.9.0, you understand:

1. **Let-chains** - Modern Rust pattern for cleaner conditionals
2. **Buffered I/O** - When and why to flush stdout
3. **Pattern matching** - `matches!` macro for elegant checks
4. **Change tracking** - Collecting modifications for user feedback
5. **UX design** - Confirmation patterns for destructive operations
6. **CLI conventions** - `--yes` flags for scripting
7. **Partial mutations** - Modifying only specified fields
8. **No-op detection** - Preventing wasted operations
9. **Feature classification** - Feature vs Enhancement
10. **Error handling** - Input validation with clear messages
11. **TableLayout pattern** - Separating layout from rendering (Builder Pattern)
12. **Single Responsibility** - Struct encapsulation for better maintainability

---

## üîó Resources

- [Code v1.9.0](https://github.com/joaofelipegalvao/todo-cli/tree/v1.9.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v1.8.0...v1.9.0)
- [Let-chains RFC](https://rust-lang.github.io/rfcs/2497-if-let-chains.html)
- [matches! macro docs](https://doc.rust-lang.org/std/macro.matches.html)
- [io::Write trait](https://doc.rust-lang.org/std/io/trait.Write.html)
- [Clap conflicts_with](https://docs.rs/clap/latest/clap/_derive/_cookbook/typed_derive/index.html)

---

## Next Steps

**You now have a production-ready task manager!** Future enhancements could include:

- **Recurring tasks** - Daily, weekly, monthly repeats
- **Subtasks** - Nested task hierarchies
- **Batch operations** - Edit multiple tasks at once
- **Undo/redo** - Operation history
- **Templates** - Predefined task structures
- **Import/export** - Share task lists

**The foundation is solid** - with Edit and confirmations, users can confidently manage their tasks without fear of data loss.

---

**üéâ Your CLI now supports professional task editing with safety guarantees!**

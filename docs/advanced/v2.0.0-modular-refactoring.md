# v2.0.0 - Modular Refactoring (Architectural Migration)

**ğŸ¯ Goal:** Transform monolithic `main.rs` into a professional modular architecture

**ğŸ“¦ The Problem We're Solving:**

**Before v2.0.0 - Monolithic main.rs (~1200 lines):**

```rust
// main.rs - Everything in one file
use std::{fs, path::PathBuf, process};
use anyhow::{Context, Result};
// ... 20+ more imports ...

#[derive(Error, Debug)]
pub enum TodoError { /* ... */ }

struct Task { /* ... */ }
enum Priority { /* ... */ }
enum StatusFilter { /* ... */ }
// ... all structs and enums ...

impl Task { /* ... 200 lines ... */ }
impl Priority { /* ... 50 lines ... */ }

fn load_tasks() -> Result<Vec<Task>> { /* ... */ }
fn save_tasks(tasks: &[Task]) -> Result<()> { /* ... */ }
fn validate_task_id(id: usize, max: usize) -> Result<(), TodoError> { /* ... */ }
fn display_task_tabular(/* ... */) { /* ... */ }
fn display_lists(/* ... */) { /* ... */ }
fn get_data_file_path() -> Result<PathBuf> { /* ... */ }
fn confirm(message: &str) -> Result<bool> { /* ... */ }
// ... 10+ more utility functions ...

fn main() { /* ... */ }

fn run(cli: Cli) -> Result<()> {
    match cli.command {
        Commands::Add(args) => { /* 20 lines */ }
        Commands::List { /* ... */ } => { /* 150 lines */ }
        Commands::Done { id } => { /* 30 lines */ }
        Commands::Undone { id } => { /* 30 lines */ }
        Commands::Remove { id, yes } => { /* 40 lines */ }
        Commands::Edit { /* ... */ } => { /* 80 lines */ }
        Commands::Clear { yes } => { /* 40 lines */ }
        Commands::Search { query, tag } => { /* 50 lines */ }
        Commands::Tags => { /* 40 lines */ }
        Commands::Info => { /* 30 lines */ }
    }
}
```

**Problems:**

âŒ **1200 lines** scrolling up and down to find anything  
âŒ **Hard to navigate** - where is specific functionality?  
âŒ **Changes affect everything** - editing one part risks breaking others  
âŒ **Imports tangled** - mixed domain logic, I/O, display, CLI  
âŒ **Impossible to test** components in isolation  
âŒ **Cognitive overload** - too much in one place  

**After v2.0.0 - Modular Architecture:**

```
src/
â”œâ”€â”€ main.rs              # Entry point - 95 lines (was 1200!)
â”œâ”€â”€ cli.rs               # CLI definitions
â”‚
â”œâ”€â”€ models/              # Data models
â”‚   â”œâ”€â”€ mod.rs          # Re-exports
â”‚   â”œâ”€â”€ task.rs         # Task struct + business logic
â”‚   â”œâ”€â”€ priority.rs     # Priority enum
â”‚   â””â”€â”€ filters.rs      # Filter enums
â”‚
â”œâ”€â”€ commands/            # Command logic
â”‚   â”œâ”€â”€ mod.rs          # Re-exports
â”‚   â”œâ”€â”€ add.rs          # Add command
â”‚   â”œâ”€â”€ list.rs         # List with filters
â”‚   â”œâ”€â”€ done.rs         # Mark done
â”‚   â”œâ”€â”€ undone.rs       # Mark undone
â”‚   â”œâ”€â”€ remove.rs       # Remove task
â”‚   â”œâ”€â”€ edit.rs         # Edit task
â”‚   â”œâ”€â”€ clear.rs        # Clear all
â”‚   â”œâ”€â”€ search.rs       # Search
â”‚   â”œâ”€â”€ tags.rs         # List tags
â”‚   â””â”€â”€ info.rs         # Info command
â”‚
â”œâ”€â”€ display/             # UI logic
â”‚   â”œâ”€â”€ mod.rs          # Re-exports
â”‚   â”œâ”€â”€ table.rs        # Table rendering
â”‚   â””â”€â”€ formatting.rs   # Colors, date formatting
â”‚
â”œâ”€â”€ storage/             # Data persistence
â”‚   â””â”€â”€ mod.rs          # Load/save, file path
â”‚
â”œâ”€â”€ error.rs             # TodoError custom type
â”œâ”€â”€ validation.rs        # ID validation
â””â”€â”€ utils.rs             # Utilities (confirm, etc)
```

**Benefits:**

âœ… **95 lines in main.rs** - 92% reduction!  
âœ… **Know where to look** - clear file organization  
âœ… **Localized changes** - edit one file without affecting others  
âœ… **Clear imports** - dependencies are obvious  
âœ… **Testable components** - each module can be unit tested  
âœ… **Professional architecture** - industry-standard patterns  

---

## ğŸ§  Key Concepts

### Separation of Concerns

**The core principle:** Each module has **one responsibility**

```rust
models/     â†’ Data structures and business rules
commands/   â†’ Command execution logic
display/    â†’ User interface and formatting
storage/    â†’ File I/O and persistence
```

**Example: The `Task` model**

```rust
// src/models/task.rs - ONLY data and domain logic
use chrono::NaiveDate;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    pub text: String,
    pub completed: bool,
    pub priority: Priority,
    pub tags: Vec<String>,
    pub due_date: Option<NaiveDate>,
    pub created_at: NaiveDate,
}

impl Task {
    pub fn new(/* ... */) -> Self { /* ... */ }
    pub fn mark_done(&mut self) { /* ... */ }
    pub fn is_overdue(&self) -> bool { /* ... */ }
    pub fn matches_status(&self, status: StatusFilter) -> bool { /* ... */ }
}
```

**No display logic, no I/O, no CLI parsing** - just pure domain model.

### Command Pattern

**Each command in its own file:**

```rust
// src/commands/add.rs
use anyhow::Result;
use crate::models::{Priority, Task};
use crate::storage::{load_tasks, save_tasks};

pub fn execute(
    text: String,
    priority: Priority,
    tags: Vec<String>,
    due: Option<NaiveDate>,
) -> Result<()> {
    let task = Task::new(text, priority, tags, due);
    let mut tasks = load_tasks()?;
    tasks.push(task);
    save_tasks(&tasks)?;
    println!("{}", "âœ“ Task added".green());
    Ok(())
}
```

**Benefits:**

- **Self-contained** - all logic for this command in one place
- **Easy to test** - `execute()` is a pure function
- **Clear interface** - parameters define what's needed
- **Reusable** - can call from tests, other commands, APIs

### Module Re-exports

**Making modules ergonomic to use:**

```rust
// src/commands/mod.rs
pub mod add;
pub mod list;
pub mod done;
// ... etc

// Now callers can do:
use crate::commands;
commands::add::execute(/* ... */);
commands::list::execute(/* ... */);
```

**Or with selective imports:**

```rust
use crate::commands::add;
add::execute(/* ... */);
```

### Clean main.rs

**The new `main.rs` is just a dispatcher:**

```rust
// src/main.rs - 95 lines total
mod cli;
mod commands;
mod models;
mod storage;
mod display;
mod error;
mod validation;
mod utils;

use cli::{Cli, Commands};

fn main() {
    let cli = Cli::parse();
    if let Err(e) = run(cli) {
        // Error display
        process::exit(1);
    }
}

fn run(cli: Cli) -> Result<()> {
    match cli.command {
        Commands::Add(args) => {
            commands::add::execute(args.text, args.priority, args.tag, args.due)
        }
        Commands::List { status, priority, due, sort, tag } => {
            commands::list::execute(status, priority, due, sort, tag)
        }
        // ... just dispatch to command modules
    }
}
```

**That's it!** No business logic, no I/O, just routing.

---

## ğŸ“ Detailed File Structure

### Core Files (5)

**1. `main.rs` (95 lines)**

- Module declarations
- CLI parsing
- Command dispatch
- Error display

**2. `cli.rs`**

- Clap derive structures
- `Cli`, `Commands`, `AddArgs`
- No logic, just definitions

**3. `error.rs`**

- `TodoError` enum
- Custom error types
- Error messages

**4. `validation.rs`**

- `validate_task_id()`
- Input validation helpers

**5. `utils.rs`**

- `confirm()` function
- Other utilities

### Models Module (4 files)

**`models/mod.rs`**

```rust
pub mod task;
pub mod priority;
pub mod filters;

pub use task::Task;
pub use priority::Priority;
pub use filters::{StatusFilter, DueFilter, SortBy};
```

**`models/task.rs`**

- `Task` struct definition
- Business logic methods
- State queries

**`models/priority.rs`**

- `Priority` enum
- Display helpers

**`models/filters.rs`**

- `StatusFilter`, `DueFilter`, `SortBy` enums

### Commands Module (11 files)

**`commands/mod.rs`**

```rust
pub mod add;
pub mod list;
pub mod done;
pub mod undone;
pub mod remove;
pub mod edit;
pub mod clear;
pub mod search;
pub mod tags;
pub mod info;
```

**Each command file:**

```rust
pub fn execute(/* parameters */) -> Result<()> {
    // Command logic
}
```

### Display Module (3 files)

**`display/mod.rs`**

```rust
pub mod table;
pub mod formatting;

pub use table::{display_task_tabular, display_lists, TableLayout};
pub use formatting::{get_due_text, get_due_colored, render_checkbox};
```

**`display/table.rs`**

- `TableLayout` struct
- `display_task_tabular()`
- `display_lists()`

**`display/formatting.rs`**

- Date formatting helpers
- Color utilities

### Storage Module (1 file)

**`storage/mod.rs`**

```rust
pub fn load_tasks() -> Result<Vec<Task>>;
pub fn save_tasks(tasks: &[Task]) -> Result<()>;
pub fn get_data_file_path() -> Result<PathBuf>;
```

---

## ğŸ”„ Migration Example

### Before: Everything in one file

```rust
// main.rs - lines 500-550
Commands::Add(args) => {
    let task = Task::new(args.text, args.priority, args.tag, args.due);
    let mut tasks = load_tasks()?;
    tasks.push(task);
    save_tasks(&tasks)?;
    println!("{}", "âœ“ Task added".green());
}
```

### After: Modular organization

**main.rs:**

```rust
Commands::Add(args) => {
    commands::add::execute(args.text, args.priority, args.tag, args.due)
}
```

**commands/add.rs:**

```rust
use anyhow::Result;
use colored::Colorize;
use crate::models::{Priority, Task};
use crate::storage::{load_tasks, save_tasks};

pub fn execute(
    text: String,
    priority: Priority,
    tags: Vec<String>,
    due: Option<NaiveDate>,
) -> Result<()> {
    let task = Task::new(text, priority, tags, due);
    let mut tasks = load_tasks()?;
    tasks.push(task);
    save_tasks(&tasks)?;
    println!("{}", "âœ“ Task added".green());
    Ok(())
}
```

**Benefits:**

- **Clear dependencies** - imports show what this command needs
- **Focused file** - only ~30 lines vs 1200-line monster
- **Easy to find** - `src/commands/add.rs` is obvious
- **Testable** - can mock `load_tasks` and `save_tasks`

---

## ğŸ¯ Design Patterns Applied

### 1. Module Pattern

**Organizing code by feature/responsibility:**

```
commands/
  â”œâ”€â”€ add.rs     â†’ Adding tasks
  â”œâ”€â”€ list.rs    â†’ Listing and filtering
  â”œâ”€â”€ remove.rs  â†’ Removing tasks
  â””â”€â”€ ...
```

Each module is **cohesive** - related functionality stays together.

### 2. Facade Pattern

**Simplified public interface through re-exports:**

```rust
// Internal structure:
models/task.rs
models/priority.rs

// Public API (models/mod.rs):
pub use task::Task;
pub use priority::Priority;

// Usage - clean!
use crate::models::{Task, Priority};
```

### 3. Single Responsibility Principle

**Each file has one job:**

- `storage/mod.rs` - **only** file I/O
- `display/table.rs` - **only** table rendering
- `commands/add.rs` - **only** add command logic

**No mixing concerns!**

### 4. Dependency Inversion

**High-level modules depend on abstractions:**

```rust
// commands/add.rs depends on storage abstraction
use crate::storage::{load_tasks, save_tasks};

// Doesn't know about JSON, file paths, etc.
// Can easily swap storage implementation
```

---

## ğŸ“Š Impact Metrics

### Code Organization

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| `main.rs` size | 1200 lines | 95 lines | **-92%** |
| Files | 1 | 19 | Better organization |
| Modules | 0 | 6 | Clear separation |
| Longest file | 1200 lines | ~150 lines | Manageable size |

### Developer Experience

| Aspect | Before | After |
|--------|--------|-------|
| **Find a function** | Scroll through 1200 lines | Open specific file (20-150 lines) |
| **Add new command** | Find space in main.rs, add to giant match | Create new file in commands/ |
| **Modify display** | Risk breaking everything | Edit display/ module only |
| **Change storage** | Mixed with everything | Edit storage/ module only |
| **Write tests** | Difficult - everything coupled | Easy - import specific modules |

### Maintainability

**Time to find and modify code:**

```
Before: Find "add" in 1200-line file â†’ 2-5 minutes
After:  Open commands/add.rs â†’ 10 seconds
```

**Risk of breaking changes:**

```
Before: Change anything â†’ test everything
After:  Change display â†’ only test display
```

---

## ğŸ§ª Testing Benefits

### Before - Hard to Test

```rust
// Can't test in isolation
// Must compile entire 1200-line file
// No clear boundaries
```

### After - Easy to Test

**Unit tests for models:**

```rust
// tests/task_tests.rs
use todo_cli::models::Task;

#[test]
fn test_task_is_overdue() {
    let task = Task::new(
        "Test".to_string(),
        Priority::High,
        vec![],
        Some(NaiveDate::from_ymd(2020, 1, 1))
    );
    assert!(task.is_overdue());
}
```

**Integration tests for commands:**

```rust
// tests/add_command_tests.rs
use todo_cli::commands::add;

#[test]
fn test_add_command() {
    // Can test add command in isolation
    let result = add::execute(/* ... */);
    assert!(result.is_ok());
}
```

**Mocking storage:**

```rust
// Can create mock storage for testing
trait TaskStorage {
    fn load(&self) -> Result<Vec<Task>>;
    fn save(&self, tasks: &[Task]) -> Result<()>;
}
```

---

## ğŸš€ Future Extensibility

### Adding a New Command

**Before:**

1. Scroll to line ~1100 in main.rs
2. Find the match statement
3. Add 50+ lines in the middle of the file
4. Hope you didn't break anything

**After:**

1. Create `src/commands/my_command.rs`
2. Implement `pub fn execute(/* ... */) -> Result<()>`
3. Add to `Commands` enum in `cli.rs`
4. Add one line in `main.rs` match
5. Export in `commands/mod.rs`

**Example:**

```rust
// src/commands/archive.rs
pub fn execute() -> Result<()> {
    // Archive completed tasks
    Ok(())
}
```

```rust
// cli.rs
enum Commands {
    // ...
    Archive,
}
```

```rust
// main.rs
Commands::Archive => commands::archive::execute(),
```

### Changing Storage Backend

**Before:** Storage logic mixed everywhere

**After:** Edit **only** `storage/mod.rs`

```rust
// storage/mod.rs
// Change from JSON to SQLite:
pub fn load_tasks() -> Result<Vec<Task>> {
    // New implementation with SQLite
}

pub fn save_tasks(tasks: &[Task]) -> Result<()> {
    // New implementation with SQLite
}

// All commands automatically use new storage!
```

---

## ğŸ’¡ Best Practices Demonstrated

### 1. Module Visibility

```rust
// Public API (exposed to other modules)
pub fn load_tasks() -> Result<Vec<Task>>

// Private helper (internal to module)
fn validate_json(content: &str) -> Result<()>
```

### 2. Re-exports for Ergonomics

```rust
// models/mod.rs
pub use task::Task;
pub use priority::Priority;

// Users don't need to know internal structure
use crate::models::{Task, Priority};
// Instead of:
use crate::models::task::Task;
use crate::models::priority::Priority;
```

### 3. Import Organization

```rust
// Standard library
use std::fs;

// External crates
use anyhow::Result;
use colored::Colorize;

// Internal modules
use crate::models::Task;
use crate::storage::load_tasks;
```

### 4. Error Handling Layers

```rust
// Domain errors (error.rs)
pub enum TodoError { /* ... */ }

// Application errors (anyhow in commands)
pub fn execute() -> Result<()> { /* ... */ }
```

---

## ğŸ”— Resources

- [Code v2.0.0](https://github.com/joaofelipegalvao/todo-cli/tree/v2.0.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v1.9.0...v2.0.0)
- [Rust Book - Modules](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)

---

## ğŸ“ Learning Outcomes

After studying v2.0.0, you understand:

1. **Module organization** - Structuring projects as they grow
2. **Separation of concerns** - Each module has one responsibility
3. **Re-exports** - Creating clean public APIs
4. **Command pattern** - Organizing command-line operations
5. **Testability** - How architecture enables testing
6. **Scalability** - How to grow projects without complexity explosion
7. **Professional architecture** - Industry-standard Rust patterns

---

**Next Steps:**

The architecture is now ready to scale to **10,000+ lines** without becoming unmaintainable. Future features will benefit from this solid foundation:

- Tests (v2.1)
- CI/CD pipeline (v2.2)
- Backend abstraction with traits (v2.3)
- Plugin system (v3.0)

---

**ğŸ‰ The project is now professionally architected!**

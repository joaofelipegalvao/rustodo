//! Handler for `todo edit <ID>`.
//!
//! Applies partial updates to an existing task. Only fields explicitly
//! provided by the caller are changed; everything else is preserved.
//! Validates dependency additions for self-references and cycles before
//! mutating any state.

use anyhow::Result;
use colored::Colorize;

use crate::cli::EditArgs;
use crate::date_parser;
use crate::error::TodoError;
use crate::models::detect_cycle;
use crate::storage::Storage;
use crate::validation::{self, validate_task_id};

pub fn execute(storage: &impl Storage, args: EditArgs) -> Result<()> {
    let due = if let Some(ref due_str) = args.due {
        Some(date_parser::parse_date(due_str)?)
    } else {
        None
    };

    let mut tasks = storage.load()?;
    validate_task_id(args.id, tasks.len())?;

    let mut changes = Vec::new();

    // === Validate dependencies before mutating ===
    for &dep_id in &args.add_dep {
        if dep_id == args.id {
            return Err(TodoError::SelfDependency { task_id: args.id }.into());
        }
        validate_task_id(dep_id, tasks.len())?;
        detect_cycle(&tasks, args.id, dep_id).map_err(TodoError::DependencyCycle)?;
        if tasks[args.id - 1].depends_on.contains(&dep_id) {
            return Err(TodoError::DuplicateDependency {
                task_id: args.id,
                dep_id,
            }
            .into());
        }
    }
    for &dep_id in &args.remove_dep {
        if !tasks[args.id - 1].depends_on.contains(&dep_id) {
            return Err(TodoError::DependencyNotFound {
                task_id: args.id,
                dep_id,
            }
            .into());
        }
    }

    let task = &mut tasks[args.id - 1];

    // === Text ===
    if let Some(new_text) = args.text {
        if new_text.trim().is_empty() {
            return Err(anyhow::anyhow!("Task text cannot be empty"));
        }
        if task.text != new_text {
            task.text = new_text.clone();
            changes.push(format!("text → {}", new_text.bright_white()));
        }
    }

    // === Priority ===
    if let Some(new_priority) = args.priority
        && task.priority != new_priority
    {
        task.priority = new_priority;
        changes.push(format!("priority → {}", new_priority.letter()));
    }

    // === Project ===
    if args.clear_project {
        if task.project.is_some() {
            let old = task.project.take().unwrap();
            changes.push(format!("project cleared -> was {}", old.dimmed()));
        }
    } else if let Some(new_project) = args.project {
        validation::validate_project_name(&new_project)?;
        if task.project.as_deref() != Some(&new_project) {
            task.project = Some(new_project.clone());
            changes.push(format!("project -> {}", new_project.cyan()));
        }
    }

    // === Tags ===
    if args.clear_tags {
        if !task.tags.is_empty() {
            let old_tags = task.tags.clone();
            task.tags.clear();
            changes.push(format!(
                "tags cleared → was [{}]",
                old_tags.join(", ").dimmed()
            ));
        }
    } else {
        // Remove specific tags
        if !args.remove_tag.is_empty() {
            let before_len = task.tags.len();
            let mut removed = Vec::new();

            task.tags.retain(|t| {
                if args.remove_tag.contains(t) {
                    removed.push(t.clone());
                    false
                } else {
                    true
                }
            });

            if !removed.is_empty() {
                changes.push(format!("removed tags → [{}]", removed.join(", ").red()));
            } else if before_len > 0 {
                // User tried to remove tags that don't exist
                return Err(anyhow::anyhow!(
                    "None of the specified tags [{}] exist in task #{}",
                    args.remove_tag.join(", "),
                    args.id
                ));
            }
        }

        // Add new tags
        if !args.add_tag.is_empty() {
            validation::validate_tags(&args.add_tag)?;
            let mut added = Vec::new();

            for new_tag in &args.add_tag {
                if !task.tags.contains(new_tag) {
                    task.tags.push(new_tag.clone());
                    added.push(new_tag.clone());
                }
            }

            if !added.is_empty() {
                changes.push(format!("added tags → [{}]", added.join(", ").cyan()));
            }
        }
    }

    // === Due date ===
    if args.clear_due {
        if task.due_date.is_some() {
            task.due_date = None;
            changes.push("due date → cleared".dimmed().to_string());
        }
    } else if let Some(new_due) = due
        && task.due_date != Some(new_due)
    {
        task.due_date = Some(new_due);
        changes.push(format!("due date → {}", new_due.to_string().cyan()));
    }

    // === Dependencies ===
    if args.clear_deps {
        if !task.depends_on.is_empty() {
            let old = task
                .depends_on
                .drain(..)
                .map(|id| format!("#{}", id))
                .collect::<Vec<_>>()
                .join(", ");
            changes.push(format!("dependencies cleared → was [{}]", old.dimmed()));
        }
    } else {
        if !args.remove_dep.is_empty() {
            task.depends_on.retain(|d| !args.remove_dep.contains(d));
            let removed = args
                .remove_dep
                .iter()
                .map(|id| format!("#{}", id))
                .collect::<Vec<_>>()
                .join(", ");
            changes.push(format!("removed deps → [{}]", removed.red()));
        }
        if !args.add_dep.is_empty() {
            for dep_id in &args.add_dep {
                task.depends_on.push(*dep_id);
            }
            let added = args
                .add_dep
                .iter()
                .map(|id| format!("#{}", id))
                .collect::<Vec<_>>()
                .join(", ");
            changes.push(format!("added deps → [{}]", added.cyan()));
        }
    }

    // Check if anything was actually changed
    if changes.is_empty() {
        println!(
            "{} No changes made (values are already set to the specified values).",
            "".blue()
        );
        return Ok(());
    }

    storage.save(&tasks)?;

    println!("{} Task #{} updated:", "✓".green(), args.id);
    for change in changes {
        println!("  • {}", change);
    }

    Ok(())
}
